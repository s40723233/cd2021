var tipuesearch = {"pages": [{'title': 'About', 'text': '此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作 \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n', 'tags': '', 'url': 'About.html'}, {'title': 'WORKS', 'text': '', 'tags': '', 'url': 'WORKS.html'}, {'title': 'stage 1', 'text': '', 'tags': '', 'url': 'stage 1.html'}, {'title': 'W1', 'text': '打開GITHUB \n 進入reposipories \n 開新專案 \n \n 輸入自己的組別 \n \n \n \n', 'tags': '', 'url': 'W1.html'}, {'title': 'W2~W3', 'text': 'W2主題擺鐘棘輪 \n \n 動機:看到時鐘就想到光陰的流逝，藉由研究單擺鐘的運動原理來提醒我們珍惜時間的重要性。 \n 組長:40723141 楊先豪 \n 組員:40723233 陳謙諭 \n 一開始打算著手研究單擺鐘內部構造的時候我們以為構造會非常複雜。 \n \n 後來上網查詢了很多資料才發現，單擺鐘最重要的是諸多齒輪當中一個叫擒縱機構的部分。 \n \n 它的運作原理是靠著鐘擺底下掛的重物來回擺盪，帶動擒爪左右轉動，當轉動到底時，擒爪會卡入擒輪的齒縫使其停滯，來達到秒針運作的效果。 \n \n 擒縱器因為不同的設計者有多種類型，每一款單擺鐘的擒縱器形式都不一定相同 \n \n 上網查找之後我們找到的資料幾乎都是運作方式的講解圖，我們嘗試用很多關鍵字搜尋過，像是「擒縱機構」加上「零件圖」、「工程圖」、「規格」等字眼，直到最後用擒縱機構的英文「escapement」加上「cad」才找到有標示尺寸的零件圖，之後我們就開始進行繪製。 \n \n 零件一 \n \n 零件二 \n \n 零件三 \n \n 組合圖 \n \n', 'tags': '', 'url': 'W2~W3.html'}, {'title': 'W4', 'text': '零件組合 \n 組合圖 \n \n \n', 'tags': '', 'url': 'W4.html'}, {'title': 'W5', 'text': '\n', 'tags': '', 'url': 'W5.html'}, {'title': 'stage 2', 'text': '', 'tags': '', 'url': 'stage 2.html'}, {'title': 'W6', 'text': '題目介紹 \n 擬定題目:窗簾機構 \n 想讓窗簾能夠像人的瞳孔自動調整進光量,所以藉由下圖伸縮機構及參考網站,讓窗簾智慧化 \n \n 工作分配 \n 40823227: 編輯小組倉儲、網站、模擬機構 \n 40823241:繪圖、製作簡報、影片 \n 40723233:參與討論 \n 40723141:提供題材 \n', 'tags': '', 'url': 'W6.html'}, {'title': 'W7', 'text': '機構設計 \n 從簡圖開始到網路上查詢 \n 最後找到模擬作動的gif檔 \n 所以我們決定按照類似的機構製作 窗簾伸縮機構 \n 已先繪製完主體為優先 \n 這是我們設計的零組件: \n 滑軌 \n \n 連桿 \n \n 輪子 \n \n 感光裝置 \n \n 布幕 \n \n', 'tags': '', 'url': 'W7.html'}, {'title': 'W8', 'text': '機構組裝 \n 將上禮拜的零組件組合起來 \n 滑軌 \n \n 連桿 \n \n 輪子 \n \n 感光裝置 \n \n 布幕 \n \n 組合完成機構 \n \n', 'tags': '', 'url': 'W8.html'}, {'title': 'W9', 'text': '\n', 'tags': '', 'url': 'W9.html'}, {'title': 'stage 3', 'text': '', 'tags': '', 'url': 'stage 3.html'}, {'title': 'W10', 'text': '連線ipv4 \n \n 用cmd確認是否有連線 \n \n \n', 'tags': '', 'url': 'W10.html'}, {'title': '小組task', 'text': 'task 1 \n 讀取 stage3_2a.txt, 建立 Stage3 的分組倉儲, 分組網頁, 以及各組員倉儲及網頁連結. \n 已知 \xa0 stage3_2a.txt \xa0 與 \xa0 stage3_2b.txt \xa0 內容, 以及初步資料讀取程式: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n \n \n \n # open file, default is read mode, since txt content no chinese char \n # no encoding = "UTF-8" is needed \n with  open ( "stage3_2a.txt" ) as fh: \n \xa0\xa0\xa0\xa0 # readlines will read into the whole line and put into list format \n \xa0\xa0\xa0\xa0 # has \\n at the end of each line \n \xa0\xa0\xa0\xa0 data  =   fh.readlines() \n #print(len(data)) \n for   i  in   range ( len (data)): \n \xa0\xa0\xa0\xa0 group  =   data[i].rstrip( "\\n" ).split( "\\t" ) \n \xa0\xa0\xa0\xa0 print (group) \n # the following will use group data to generate needed html \n \n \n \n \n \n \n \n 以下為每組亂數抽選 2 名組員的程式碼: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n \n \n \n # open file, default is read mode, since txt content no chinese char \n # no encoding = "UTF-8" is needed \n import   random \n \xa0 \n # number of group menber to draw \n num  =   2 \n \xa0 \n # check if data is "" or not \n def   notVacant(data): \n \xa0\xa0\xa0\xa0 if   data  = =   "": \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   False \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   True \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n with  open ( "stage3_2b.txt" ) as fh: \n \xa0\xa0\xa0\xa0 # readlines will read into the whole line and put into list format \n \xa0\xa0\xa0\xa0 # has \\n at the end of each line \n \xa0\xa0\xa0\xa0 data  =   fh.readlines() \n #print(len(data)) \n # big group list \n bgroup  =   [] \n # count from the second group member \n sgroup  =   [] \n for   i  in   range ( len (data)): \n \xa0\xa0\xa0\xa0 group  =   data[i].rstrip( "\\n" ).split( "\\t" ) \n \xa0\xa0\xa0\xa0 #print(group) \n \xa0\xa0\xa0\xa0 # use mem to count the total number of each group \n \xa0\xa0\xa0\xa0 mem  =   0 \n \xa0\xa0\xa0\xa0 # final group data \n \xa0\xa0\xa0\xa0 fgroup  =   [] \n \xa0\xa0\xa0\xa0 # count from the second group member, eliminate the first element \n \xa0\xa0\xa0\xa0 sgroup  =   group[ 1 :] \n \xa0\xa0\xa0\xa0 # get only the odd index number \n \xa0\xa0\xa0\xa0 igroup  =   [i  for   i  in   range ( len (sgroup))  if   i  %   2   = =   1 ] \n \xa0\xa0\xa0\xa0 for   j  in   igroup: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # index starts from 0 which is j-1 when j=1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   notVacant(sgroup[j - 1 ])  = =   True : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 mem  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fgroup.append(sgroup[j - 1 ]) \n \xa0\xa0\xa0\xa0 print ( "group "   +   str (i + 1 )  +   ":"   +   str (mem)) \n \xa0\xa0\xa0\xa0 # shuffle the fgroup list \n \xa0\xa0\xa0\xa0 random.shuffle(fgroup) \n \xa0\xa0\xa0\xa0 # draw num of member from final group list: fgroup \n \xa0\xa0\xa0\xa0 for   k  in   range (num): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 try : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print (fgroup[k]) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 except : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # num is greater than total number of this group \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "no such member" ) \n \xa0\xa0\xa0\xa0 # seperator \n \xa0\xa0\xa0\xa0 print ( "-" * 20 ) \n # the following will use group data to generate needed html \n \n \n \n \n \n \n \n 以下為各分組倉儲, 分組網站與學員倉儲及學員網站連結: \n 成果: \n stage3-bg1 repo \xa0 | \xa0 stage3-bg1 site \xa0 | \xa0 40823245 repo \xa0 | \xa0 40823245 site \xa0 | \xa0 40823251 repo \xa0 | \xa0 40823251 site \xa0 | \xa0 40823208 repo \xa0 | \xa0 40823208 site \xa0 | \xa0 40823213 repo \xa0 | \xa0 40823213 site \xa0 | \xa0 40823232 repo \xa0 | \xa0 40823232 site \xa0 | \xa0 40823234 repo \xa0 | \xa0 40823234 site \xa0 | \xa0 40823235 repo \xa0 | \xa0 40823235 site \xa0 | \xa0 40823246 repo | \xa0 40823246 site ---------- stage3-bg2 repo \xa0 | \xa0 stage3-bg2 site \xa0 | \xa0 40823217 repo \xa0 | \xa0 40823217 site \xa0 | \xa0 40823201 repo \xa0 | \xa0 40823201 site \xa0 | \xa0 40823209 repo \xa0 | \xa0 40823209 site \xa0 | \xa0 40823210 repo \xa0 | \xa0 40823210 site \xa0 | \xa0 40823206 repo \xa0 | \xa0 40823206 site \xa0 | \xa0 40823207 repo \xa0 | \xa0 40823207 site \xa0 | \xa0 40823223 repo \xa0 | \xa0 40823223 site \xa0 | \xa0 40823224 repo | \xa0 40823224 site ---------- stage3-bg3 repo \xa0 | \xa0 stage3-bg3 site \xa0 | \xa0 40823236 repo \xa0 | \xa0 40823236 site \xa0 | \xa0 40823202 repo \xa0 | \xa0 40823202 site \xa0 | \xa0 40823203 repo \xa0 | \xa0 40823203 site \xa0 | \xa0 40823212 repo \xa0 | \xa0 40823212 site \xa0 | \xa0 40823219 repo \xa0 | \xa0 40823219 site \xa0 | \xa0 40823222 repo \xa0 | \xa0 40823222 site \xa0 | \xa0 40823231-2 repo \xa0 | \xa0 40823231-2 site \xa0 | \xa0 40823244 repo | \xa0 40823244 site ---------- stage3-bg4 repo \xa0 | \xa0 stage3-bg4 site \xa0 | \xa0 40823239 repo \xa0 | \xa0 40823239 site \xa0 | \xa0 s40723140 repo \xa0 | \xa0 s40723140 site \xa0 | \xa0 s40723128 repo \xa0 | \xa0 s40723128 site \xa0 | \xa0 s40723139 repo \xa0 | \xa0 s40723139 site \xa0 | \xa0 s40723106 repo \xa0 | \xa0 s40723106 site \xa0 | \xa0 s40723135 repo \xa0 | \xa0 s40723135 site \xa0 | \xa0 s40723143 repo \xa0 | \xa0 s40723143 site \xa0 | \xa0 s40723215 repo | \xa0 s40723215 site ---------- stage3-bg5 repo \xa0 | \xa0 stage3-bg5 site \xa0 | \xa0 40823221 repo \xa0 | \xa0 40823221 site \xa0 | \xa0 40823204 repo \xa0 | \xa0 40823204 site \xa0 | \xa0 40823205 repo \xa0 | \xa0 40823205 site \xa0 | \xa0 40823220 repo \xa0 | \xa0 40823220 site \xa0 | \xa0 40823228 repo \xa0 | \xa0 40823228 site \xa0 | \xa0 40823237 repo \xa0 | \xa0 40823237 site \xa0 | \xa0 40823242 repo \xa0 | \xa0 40823242 site \xa0 | \xa0 40823250 repo | \xa0 40823250 site \xa0 | \xa0 40832244 repo | \xa0 40832244 site ---------- stage3-bg6 repo \xa0 | \xa0 stage3-bg6 site \xa0 | \xa0 40823225 repo \xa0 | \xa0 40823225 site \xa0 | \xa0 40823214 repo \xa0 | \xa0 40823214 site \xa0 | \xa0 40823218 repo \xa0 | \xa0 40823218 site \xa0 | \xa0 40823211 repo \xa0 | \xa0 40823211 site \xa0 | \xa0 40823248 repo \xa0 | \xa0 40823248 site \xa0 | \xa0 40823247 repo \xa0 | \xa0 40823247 site \xa0 | \xa0 40823216 repo \xa0 | \xa0 40823216 site \xa0 | \xa0 40823238 repo | \xa0 40823238 site ---------- stage3-bg7 repo \xa0 | \xa0 stage3-bg7 site \xa0 | \xa0 40623144 repo \xa0 | \xa0 40623144 site \xa0 | \xa0 40823233 repo \xa0 | \xa0 40823233 site \xa0 | \xa0 s40723224 repo \xa0 | \xa0 s40723224 site \xa0 | \xa0 40823241 repo \xa0 | \xa0 40823241 site \xa0 | \xa0 40423155 repo \xa0 | \xa0 40423155 site \xa0 | \xa0 40823227 repo \xa0 | \xa0 40823227 site \xa0 | \xa0 s40723233 repo \xa0 | \xa0 s40723233 site ---------- \n task 2 \n 請各組員分別將個人在 stage1 與 stage2 所完成的 coppeliasim 場景, 採 Python remote API 進行操控, 並將過程拍成影片後, 放在個人與分組網站上. \n stage3 專案中的 CoppeliaSim 請一律使用 \xa0 4.2.0 版 . \n 範例: \xa0 http://mde.tw/cad2020/content/CoppeliaSim.html \n W10 範例: \n 各班上課時所分配到的內部 IP, 192.168.192.1+組別+排序別 \n 意即, 第五組排序別第一即為該組組長, 其 IP 為 192.168.192.151 \n 以 \xa0 http://mde.tw/cad2020/downloads/coppeliasim/vrep_remoteapi_ex.7z \xa0 為例, 每一個 Python3 remote api 程式執行需要 \xa0 sim.py , \xa0 simConst.py \xa0 與 \xa0 remoteApi.dll \xa0 等三個檔案, 若針對 2w1a.ttt 場景, 以下列 Python 程式對位於 192.168.192.1 伺服器上的 CoppeliaSim 場景進行操控: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n \n \n \n import   sim as vrep \n import   math \n import   random \n import   time \n \xa0 \n print   ( \'Start\' ) \n \xa0 \n # Close eventual old connections \n vrep.simxFinish( - 1 ) \n # Connect to V-REP remote server \n clientID  =   vrep.simxStart( \'192.168.192.1\' ,  19997 ,  True ,  True ,  5000 ,  5 ) \n \xa0 \n if   clientID ! =   - 1 : \n \xa0\xa0\xa0\xa0 print   ( \'Connected to remote API server\' ) \n \xa0 \n \xa0\xa0\xa0\xa0 res  =   vrep.simxAddStatusbarMessage( \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 clientID,  "teacher" , \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simx_opmode_oneshot) \n \xa0\xa0\xa0\xa0 if   res  not   in   (vrep.simx_return_ok, vrep.simx_return_novalue_flag): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Could not add a message to the status bar." ) \n \xa0\xa0\xa0\xa0 # Communication operating mode with the remote API : wait for its answer before continuing (blocking mode) \n \xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiConstants.htm \n \xa0\xa0\xa0\xa0 opmode  =   vrep.simx_opmode_oneshot_wait \n \xa0 \n \xa0\xa0\xa0\xa0 # Try to retrieve motors and robot handlers \n \xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectHandle \n \xa0\xa0\xa0\xa0 ret1, wristHandle  =   vrep.simxGetObjectHandle(clientID,  "WristMotor" , opmode) \n \xa0\xa0\xa0\xa0 ret2, elbowHandle  =   vrep.simxGetObjectHandle(clientID,  "ElbowMotor" , opmode) \n \xa0\xa0\xa0\xa0 ret3, shoulderHandle  =   vrep.simxGetObjectHandle(clientID,  "ShoulderMotor" , opmode) \n \xa0\xa0\xa0\xa0 ret4, robotHandle  =   vrep.simxGetObjectHandle(clientID,  "2W1A" , opmode) \n \xa0 \n \xa0\xa0\xa0\xa0 # If handlers are OK, execute three random simulations \n \xa0\xa0\xa0\xa0 if   ret1  = =   0   and   ret2  = =   0   and   ret3  = =   0 : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 random.seed() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   i  in   range ( 0 ,  3 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Start the simulation \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStartSimulation \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxStartSimulation(clientID, opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "----- Simulation started -----" ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Start getting the robot position \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Unlike other commands, we will use a streaming operating mode \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectPosition \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pret, robotPos  =   vrep.simxGetObjectPosition(clientID, robotHandle,  - 1 , vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "2w1a position: (x = "   +   str (robotPos[ 0 ])  + \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", y = "   +   str (robotPos[ 1 ])  +   ")" ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Start getting the robot orientation \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Unlike other commands, we will use a streaming operating mode \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetObjectOrientation \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 oret, robotOrient  =   vrep.simxGetObjectOrientation(clientID, robotHandle,  - 1 , vrep.simx_opmode_streaming) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "2w1a orientation: (x = "   +   str (robotOrient[ 0 ])  +   \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", y = "   +   str (robotOrient[ 1 ])  + \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", z = "   +   str (robotOrient[ 2 ])  +   ")" ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Make the robot move randomly five times \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 for   j  in   range ( 0 ,  5 ): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Generating random positions for the motors \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 awrist  =   random.randint( 0 ,  300 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 aelbow  =   random.randint( 0 ,  300 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ashoulder  =   random.randint( 0 ,  300 ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # The control functions use Radians to determine the target position. \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Here, we use maths.radians to convert degrees into radians. \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxSetJointTargetPosition \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Motors target positions: "   +   str (ashoulder)  +   " "   +   str (aelbow)  +   " "   +   str (awrist)) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, wristHandle, math.radians(awrist), opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, elbowHandle, math.radians(aelbow), opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxSetJointTargetPosition(clientID, shoulderHandle, math.radians(ashoulder), opmode) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Wait in order to let the motors finish their movements \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Tip: there must be a more efficient way to do it... \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 5 ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Get the motors effective positions after the movement sequence \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxGetJointPosition \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pwrist  =   vrep.simxGetJointPosition(clientID, wristHandle, opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pelbow  =   vrep.simxGetJointPosition(clientID, elbowHandle, opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pshoulder  =   vrep.simxGetJointPosition(clientID, shoulderHandle, opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "Motors reached positions: "   +   str (ashoulder)  +   " "   +   str (aelbow)  +   " "   +   str (awrist)) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Get the robot position after the movement sequence \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 pret, robotPos  =   vrep.simxGetObjectPosition(clientID, robotHandle,  - 1 , vrep.simx_opmode_buffer) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "2w1a position: (x = "   +   str (robotPos[ 0 ])  + \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", y = "   +   str (robotPos[ 1 ])  +   ")" ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # Get the robot orientation after the movement sequence \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 oret, robotOrient  =   vrep.simxGetObjectOrientation(clientID, robotHandle,  - 1 , vrep.simx_opmode_buffer) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "2w1a orientation: (x = "   +   str (robotOrient[ 0 ])  + \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", y = "   +   str (robotOrient[ 1 ])  + \\ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ", z = "   +   str (robotOrient[ 2 ])  +   ")" ) \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # End the simulation, wait to be sure V-REP had the time to stop it entirely \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxStopSimulation \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 vrep.simxStopSimulation(clientID, opmode) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 time.sleep( 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "----- Simulation ended -----" ) \n \xa0 \n \xa0\xa0\xa0\xa0 # Close the connection to V-REP remote server \n \xa0\xa0\xa0\xa0 # http://www.coppeliarobotics.com/helpFiles/en/remoteApiFunctionsPython.htm#simxFinish \n \xa0\xa0\xa0\xa0 vrep.simxFinish(clientID) \n else : \n \xa0\xa0\xa0\xa0 print   ( \'Failed connecting to remote API server\' ) \n print   ( \'End\' ) \n \n \n \n \n \n \n \n CoppeliaSim 場景 remote API 協同監控流程: \n \n 各組員下載 \xa0 https://portableapps.com/apps/music_video/obs-studio-portable \n 擔任 CoppliaSim 場景直播者時, 必須以 @gm 帳號登入 Youtube 後, 啟動 Live stream 取得直播串流金鑰, 將金鑰輸入 OBS 後, 擷取電腦顯示器啟動串流, 然後利用 copy video url 取得直播網址. \n 將直播網誌公布在 \xa0 https://gitter.im/mdecourse/cd2021 , 並附上伺服器 IPv4 內部網路 IP 位址與場景開放埠號. \n 直播者同時必須在個人網站上公布 Python remote API 操控直播場景相關參變數以及監控條件. \n 待遠端各協同操控學員準備就緒後, 完成操控流程後將所錄製的影片嵌入個人與分組網站中. \n \n task 3 \n 每週各組按照組員順序, 於每堂課程時段, 輪流由 2-3 名學員啟動 OBS + Youtube 直播 (每週每位學員均需輪流負責直播工作項目內容), 並在開播前將直播 URL 公布於課程 gitter, 以展示該時段該組針對 stage3 分組專題工作項目的協同過程. (即每週各組於上課時段均會有四段協同設計影片分別嵌入各負責直播錄影組員的網頁與分組網頁). \n 各直播錄影時段, 各直播組員 (2-3 名) 應先規劃進行中工作項目的網際簡報資料, 並依照簡報內容逐一介紹所要展示或討論的協同設計項目. \n 當其他組別在執行 stage3 分組專題內容碰到問題時, 應按照順序採取下列步驟解決問題: \n \n 利用協同直播錄影時段, 輔以網際簡報資料, 明確說明所遭遇之問題情境. \n 上述影片上傳並嵌入個人網站與分組網站後, 根據問題描述影片內容, 尋求其他組在其分段直播時段說明如何解題. \n \n 各組組員於進行 stage3 分組專題期間, 均應協同負責從 零組件設計繪圖 , \xa0 零件轉檔 , 零組件轉入 \xa0 CoppeliaSim 進行設定 , \xa0 Lua 監控 , \xa0 Python 監控 , \xa0 直播錄影 , ssh 維護 個人網際簡報 , ssh 維護 個人網站 , 並協同參與維護 分組網站 等工作項目, 若過程中遭遇問題, 則根據上述步驟進行解題. \n 直播前: 準備網際投影片 \n 開啟直播: 將直播投影片(即直播主題) 與直播連結登錄在 \xa0 https://gitter.im/mdecourse/cd2021 \n 直播結束後: 將影片嵌入個人與分組網頁後, 連結繳交至 \xa0 https://github.com/mdecourse/cd2021/discussions/24 \n 抽選各分組直播學員的程式: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n \n \n \n # open file, default is read mode, since txt content no chinese char \n # no encoding = "UTF-8" is needed \n import   random \n \xa0 \n # number of group menber to draw \n num  =   2 \n \xa0 \n # check if data is "" or not \n def   notVacant(data): \n \xa0\xa0\xa0\xa0 if   data  = =   "": \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   False \n \xa0\xa0\xa0\xa0 else : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 return   True \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 \xa0 \n with  open ( "stage3_2b.txt" ) as fh: \n \xa0\xa0\xa0\xa0 # readlines will read into the whole line and put into list format \n \xa0\xa0\xa0\xa0 # has \\n at the end of each line \n \xa0\xa0\xa0\xa0 data  =   fh.readlines() \n #print(len(data)) \n # big group list \n bgroup  =   [] \n # count from the second group member \n sgroup  =   [] \n for   i  in   range ( len (data)): \n \xa0\xa0\xa0\xa0 group  =   data[i].rstrip( "\\n" ).split( "\\t" ) \n \xa0\xa0\xa0\xa0 #print(group) \n \xa0\xa0\xa0\xa0 # use mem to count the total number of each group \n \xa0\xa0\xa0\xa0 mem  =   0 \n \xa0\xa0\xa0\xa0 # final group data \n \xa0\xa0\xa0\xa0 fgroup  =   [] \n \xa0\xa0\xa0\xa0 # count from the second group member, eliminate the first element \n \xa0\xa0\xa0\xa0 sgroup  =   group[ 1 :] \n \xa0\xa0\xa0\xa0 # get only the odd index number \n \xa0\xa0\xa0\xa0 igroup  =   [i  for   i  in   range ( len (sgroup))  if   i  %   2   = =   1 ] \n \xa0\xa0\xa0\xa0 for   j  in   igroup: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # index starts from 0 which is j-1 when j=1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   notVacant(sgroup[j - 1 ])  = =   True : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 mem  + =   1 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 fgroup.append(sgroup[j - 1 ]) \n \xa0\xa0\xa0\xa0 print ( "group "   +   str (i + 1 )  +   ":"   +   str (mem)) \n \xa0\xa0\xa0\xa0 # shuffle the fgroup list \n \xa0\xa0\xa0\xa0 random.shuffle(fgroup) \n \xa0\xa0\xa0\xa0 # draw num of member from final group list: fgroup \n \xa0\xa0\xa0\xa0 for   k  in   range (num): \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 try : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print (fgroup[k]) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 except : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 # num is greater than total number of this group \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print ( "no such member" ) \n \xa0\xa0\xa0\xa0 # seperator \n \xa0\xa0\xa0\xa0 print ( "-" * 20 ) \n # the following will use group data to generate needed html \n \n \n \n \n \n \n \n 人形 Robot 模擬套件比較: \n A Comparison of Humanoid Robot Simulators A Quantitative Approach.pdf \n For robotic systems to be implemented in real-world scenarios, in several situations, it is preferred to develop and test them under controlled environments in order to reduce the risk of errors and unexpected behavior. \xa0In this regard, a more accessible and efficient alternative is to implement\xa0 the environment using robotic simulation tools. \n In general terms, our results show that Webots is the simulator with the lowest use ofresources, followed by V-REP, which has advantages over Gazebo, mainly because of the CPU use. \n Robot simulators allow evaluating the feasibility and efficiency of algorithms varying in type and complexity, in a more controlled environment with no disturbances avoiding the occurrence of accidents. \n', 'tags': '', 'url': '小組task.html'}, {'title': 'W11~W14', 'text': '打開安裝檔，選擇繁體中文。 \n \n 按下"下一步" \n \n 選擇安裝位置 \n \n 安裝中(約五分鐘) \n \n 安裝完成 \n \n 下方功能列按下"+"號並選擇顯示器擷取 \n \n 選擇擷取的顯示器 \n \n 打開設定->串流 \n \n 在YouTube找到串流金鑰並輸入 \n \n YouTube串流金鑰 \n \n 輸入並套用 \n \n 按下右下角"開始串流"開始直播 \n \n', 'tags': '', 'url': 'W11~W14.html'}, {'title': 'W15', 'text': '\n 影片翻譯 \n 我們在前面看到了這個簡單的雙連桿機器人關於正向運動學的講座。 \n 描述了該機器人的工具提示位姿簡單地由兩個數字，坐標 x 和 y 相對於世界坐標系。 \n 所以，這里的問題是，給定 x 和 y，我們要確定連接的角度 Q1和 Q2。 \n 我們將遵循的解決方案在這個特定的部分是一個幾何 \n 一。 \n 我們將從一個簡單的作品開始的建設。 \n 我們將覆蓋紅色三角形在我們的機器人之上。 \n 我們知道終點坐標是x，y，所以三角形的垂直高度是 y，水平寬度是 x。並且，使用畢達哥拉斯定理，我們可以寫出r 平方等於 x 平方加上 y 平方。到目前為止，很容易。現在，我們要看看這個三角形此處以紅色突出顯示，我們想確定角度α。為了做到這一點，我們需要使用余弦規則。而且，如果你對余弦有點生疏 規則，這里有一點覆習。我們有一個任意三角形。我們不必有任何直角它，我們將標記長度這條邊作為 A和相反的角度邊緣，我們將標記為小 a。而且，我們對這條邊和這條邊做同樣的事情角度，還有這條邊和這個角。所以，總而言之，雙方都被標記為首都A、B 和 C，角度標記為小a、小b和小c。 \n 所以，余弦規則就是這種關系這里。這有點像畢達哥拉斯定理，除了 對於這個額外的術語，最後的 cos一個在里面。 \n 現在，讓我們將余弦規則應用於我們看了一會兒特定的三角形前。 \n 寫下來很簡單這種特殊的關系。我們可以隔離術語 cos alpha，它給出 我們感興趣的角度α在。 \n 而且，它是根據常數定義的鏈接長度，A1 和 A2 以及位置末端執行器，x 和 y。 \n 我們可以寫出這個簡單的關系角α和Q2。 \n 而且，我們從余弦的形狀知道Q2 的 cos 必須等於負的函數cos 阿爾法。 \n 這一次，我們只寫一個表達式對於連接角 Q2 的余弦。 \n 現在，我們要再畫一個紅色三角形，我們將應用一些簡單的三角函數在這里。 \n 如果我們知道 Q2，那麽我們就知道這個長度和這個紅色三角形的長度。 \n 我們可以把這個關系寫成正弦的連接角 Q2。 \n 現在，我們可以考慮這個更大的三角形其角為β，此邊長為三角形在這里以藍色給出。 \n 並且，三角形另一邊的長度這是。 \n 所以，現在我們可以寫一個表達式此處的這些參數的角度β。回到我們畫的紅色三角形 之前，我們可以建立之間的關系 \n Q1 和角β。 \n 介紹另一個角度，這個伽馬我們可以寫出之間的關系 \n 角度伽馬和工具提示坐標 x和y \n 現在，我們可以寫出一個簡單的關系我們構建的角度，伽馬和 beta 以及我們感興趣的連接角其中是 Q1。 \n 而且，總的關系看起來有些東西像這樣。 \n 相當覆雜的關系，它給了我們連接的角度，即 Q1 \n 末端執行器坐標 y 和 x，以及一堆常量，a1 和 a2，它是 \n 也是第二關節角度的函數，Q2。所以，讓我們總結一下我們有什麽派生於此。 \n 我們有 Q2 的余弦表達式我們有 Q1 的表達式。 \n 現在，余弦函數關於0.所以，如果我們知道余弦值Q2，那麽有兩種可能的解決方案，一個正角和一個負角。我們將明確選擇積極的角度，這意味著我可以寫出這個表達式這里。 \n 現在，我們有了我們所說的逆這個雙連桿機器人的運動學解決方案。 \n 我們有兩個連接角的表達式，Q1 和 Q2 在末端執行器姿勢方面 \n x 和 y，以及一堆常量。你注意到這兩個方程不是獨立的。 \n 事實上，Q1 的方程取決於Q2 的解決方案。 \n 在這種情況下，Q2 是負數，我們將用負數寫出 Q2 的解符號在反余弦前面。 \n 現在，我們需要解決 Q1，所以我們要介紹這個特殊的紅色三角形， \n 我們之前求解的角度β，以及用術語定義的角度伽馬y 和 x。 \n 現在，我們寫一個稍微不同的關系在 Q1、gamma 和 beta 之間，與什麽不同 \n 我們以前有過。涉及到符號的變化。然後，我們可以替換之前的所有方程並提出這個表達式 \n 對於 Q1。同樣，這里的符號发生了變化。 \n 以前，這是一個負面信號。 \n 而且，這里是總結形式的解決方案對於我們的雙連桿的逆運動學 \n 當機器人處於這種特定配置時，其中 Q2 為負。 \n 讓我們比較兩種解決方案，案例其中 Q2 為正，Q2 為正的情況是否定的 \n \n 這里我們有與我們相同的兩個鏈接機器人只是看著，但這次我們要使用分析方法解決它，即 我們是否會更多地依賴代數， \n 特定的線性代數而不是幾何。我們有一個表達式 E，它是齊次的表示姿勢的變換 機器人終結者，我們看了這個 \n 在上一課中，我們可以編寫 endefector構成一個基本齊次序列轉換。 Q1 的旋轉，平移 沿 X 方向 A1，旋轉Q2 然後在 X 方向上平移通過 A2。如果我展開這個，乘以所有一起轉換，我得到了表達顯示在這里；三乘三同構變換 \n 表示機器人姿態的矩陣終結者。 \n 現在對於這個特殊的兩連桿機器人，我們只對它的位置感興趣endefector，它是 X 和 Y 坐標，它們這兩個元素是同質的嗎 \n 變換矩陣，所以我要覆制那些出來。所以這里又是我們的表達 \n 對於 X 和 Y 我們要做的是一個相當常見的技巧，我們要平方並添加這兩個方程，我得到了一個關系看起來像這樣。現在我可以解決 \n 根據 endefector 的關節角度 Q2姿勢 X 和 Y 以及機器人的常數 A1 和 A2。現在我要做的是應用總和 的角度身份。我要擴展這些項，Q1 的正弦加 Q2 或 Q1 的余弦加 Q2 為了讓生活更輕松一點，我打算建造一些變電站，所以無論在哪里 我有 cos Q2，我要寫 C2 以及在哪里 \n 曾經我有正弦 Q2，我要寫 S2。這是一個相當常見的速記，當人們正在研究機器人運動學方程。 這是制作後的方程式替代品。看這兩個方程，我可以看到他們掉進了一個很好的井里已知形式，對於該形式有一個非常眾所周知的解決方案。所以我要考慮只是其中一個方程，方程為Y 並使用我們眾所周知的身份 \n 解決方案，我可以確定變量小a、小b和小c一旦我確定了這些，我就可以只需寫下 Q1 的解決方案，即在這個特定的情況下相當於 theta案件。 \n 這里再次是我們對 Q1 的表達式，覆制從上一張幻燈片結束，我們可能還記得從我們早期的工作中我們確定這種特殊的關系； X平方加Y 平方等於這個特定的覆數 表達。所以我可以用和代替它 \n 做一些簡化，我最終得到這個Q1 的表達式稍微簡單一些。和這是我得到的相同表達上一節中的幾何方法。 \n', 'tags': '', 'url': 'W15.html'}, {'title': 'W16', 'text': 'onshape繪製 \n \n 建立 CoppeliaSim 4.1.0 MTB robot 場景 \n https://drive.google.com/file/d/1wtDe918nRNeteHjFrQdC-pqFxWbL4T09/view?usp=sharing 檔案網址 \n 程式碼(lua) \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n 127 \n 128 \n 129 \n 130 \n 131 \n 132 \n 133 \n 134 \n 135 \n 136 \n 137 \n 138 \n 139 \n 140 \n 141 \n 142 \n 143 \n 144 \n 145 \n 146 \n 147 \n 148 \n 149 \n 150 \n \n \n \n function sysCall_init()  \n \xa0\xa0\xa0\xa0 axis1 = sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0 axis2 = sim.getObjectHandle( \'MTB_axis2\' ) \n \xa0\xa0\xa0\xa0 axis3 = sim.getObjectHandle( \'MTB_axis3\' ) \n \xa0\xa0\xa0\xa0 axis4 = sim.getObjectHandle( \'MTB_axis4\' ) \n \xa0\xa0\xa0\xa0 mtb3 = sim.getObjectHandle( \'MTB_link3Respondable\' ) \n \xa0\xa0\xa0\xa0 BaseFrame = sim.getObjectHandle( "BaseFrame" ) \n \xa0\xa0\xa0\xa0 block  = sim.getObjectHandle( "block" ) \n \xa0\xa0\xa0\xa0 rotation1  =   0 \n \xa0\xa0\xa0\xa0 rotation2  =   0 \n \xa0\xa0\xa0\xa0 distance3  =   0 \n \xa0\xa0\xa0\xa0 deg  =   math.pi / 180 \n end \n function sysCall_actuation()  \n \xa0\xa0\xa0\xa0 - -   吸盤往下降時, 直接貼在方塊頂部的校正值, 單位 m \n \xa0\xa0\xa0\xa0 - -   向下較正值為  4.2   mm \n \xa0\xa0\xa0\xa0 calibration  =   0.0042 \n \xa0\xa0\xa0\xa0 message, auxiliaryData = sim.getSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 while   message ~ =   - 1   do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 key = auxiliaryData[ 1 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.addStatusbarMessage( \'使用者按下 key:\' ..key) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (message = = sim.message_keypress) then \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 97 ) then  - - r right turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key r pressed axis1 angle adds  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation1  =   rotation1  +   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   r \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 115 ) then  - - l left turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key l pressed axis1 angle substract  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation1  =   rotation1  -   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   l \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 122 ) then  - - r right turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key r pressed axis1 angle adds  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation2  =   rotation2  +   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis2, rotation2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   r \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 120 ) then  - - l left turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key l pressed axis1 angle substract  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation2  =   rotation2  -   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis2, rotation2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   l \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end\xa0  - -   if \n \xa0\xa0\xa0\xa0 message, auxiliaryData = sim.getSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   while \n end  - -   function \n function sysCall_sensing()  \n - - [[ \n \xa0\xa0\xa0\xa0 - -   Read Proximity sensor ( 0 =   nothing detected,  1   =   object   detected) \n \xa0\xa0\xa0\xa0 local res  =   sim.readProximitySensor(proximity) \n \xa0\xa0\xa0\xa0 - -   Check  if   possible to insert an new box \n \xa0\xa0\xa0\xa0 if   (sim.getSimulationTime() - T_last_inserted > T_insert)  and   not   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 insertBox() \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   If proximity sensor detects an  object , stop the belt, stop inserting objects \n \xa0\xa0\xa0\xa0 if   res  = =   1   and   not   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   boolList[ 1 ] then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setScriptSimulationParameter(sim.handle_self, "conveyorBeltVelocity" , 0 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 deltaTime  =   sim.getSimulationTime() - T_last_inserted \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 hasStopped  =   true \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local box  =   table.remove(boxList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local boxDummy  =   table.remove(boxDummyList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.remove(boolList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.removeObject(box) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.removeObject(boxDummy) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   If proximity sensor detects nothing  and   belt has stopped, start belt,  continue   inserting \n \xa0\xa0\xa0\xa0 if   res  = =   0   and   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setScriptSimulationParameter(sim.handle_self, "conveyorBeltVelocity" ,beltSpeed) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 hasStopped  =   false \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 T_last_inserted  =   sim.getSimulationTime() - deltaTime \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 \xa0 \n ]] - - \n end \n function sysCall_cleanup()  \n end  \n - -   Convert a lua table into a lua syntactically correct string \n function table_to_string(tbl) \n \xa0\xa0\xa0\xa0 local result  =   "{" \n \xa0\xa0\xa0\xa0 for   k, v  in   pairs(tbl) do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   Check the key  type   (ignore  any   numerical keys  -   assume its an array) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   type (k)  = =   "string"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "[\\"" ..k.. "\\"]" .. "=" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   Check the value  type \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   type (v)  = =   "table"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result..table_to_string(v) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elseif  type (v)  = =   "boolean"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result..tostring(v) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 v  =   round (v,  4 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "\\"" ..v.. "\\"" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "," \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   Remove leading commas  from   the result \n \xa0\xa0\xa0\xa0 if   result ~ =   "" then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result:sub( 1 , result: len () - 1 ) \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 return   result.. "}" \n end \n function  round (x, n) \n \xa0\xa0\xa0\xa0 n  =   math. pow ( 10 , n  or   0 ) \n \xa0\xa0\xa0\xa0 x  =   x  *   n \n \xa0\xa0\xa0\xa0 if   x > =   0   then x  =   math.floor(x  +   0.5 )  else   x  =   math.ceil(x  -   0.5 ) end \n \xa0\xa0\xa0\xa0 return   x  /   n \n end \n \xa0 \n \xa0 \n function insertBox() \n \xa0\xa0\xa0\xa0 - -   Generate random numbers \n \xa0\xa0\xa0\xa0 local rand1  =   math.random() \n \xa0\xa0\xa0\xa0 local rand2  =   math.random() \n \xa0\xa0\xa0\xa0 local rand3  =   math.random() \n \xa0\xa0\xa0\xa0 - -   Generate random disturbances on position  and   orientation \n \xa0\xa0\xa0\xa0 local dx  =   ( 2 * rand1 - 1 ) * 0.1 \n \xa0\xa0\xa0\xa0 local dy  =   ( 2 * rand2 - 1 ) * 0.1 \n \xa0\xa0\xa0\xa0 local dphi  =   ( 2 * rand3 - 1 ) * 0.5 \n \xa0\xa0\xa0\xa0 local disturbedCoordinates  =   { 0 , 0 , 0 } \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 1 ]  =   insertCoordinate[ 1 ] + dx \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 2 ]  =   insertCoordinate[ 2 ] + dy \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 3 ]  =   insertCoordinate[ 3 ] \n \xa0\xa0\xa0\xa0 - -   Copy  and   paste box  and   boxDummy \n \xa0\xa0\xa0\xa0 local insertedObjects  =   sim.copyPasteObjects({box,boxDummy}, 0 ) \n \xa0\xa0\xa0\xa0 - -   Update last inserted box time \n \xa0\xa0\xa0\xa0 T_last_inserted  =   sim.getSimulationTime() \n \xa0\xa0\xa0\xa0 - -   Move  and   rotate \n \xa0\xa0\xa0\xa0 sim.setObjectPosition(insertedObjects[ 1 ], - 1 ,disturbedCoordinates) \n \xa0\xa0\xa0\xa0 sim.setObjectOrientation(insertedObjects[ 1 ], - 1 ,{ 0 , 0 ,dphi}) \n \xa0\xa0\xa0\xa0 - -   Store handles to boxes  and   dummies \n \xa0\xa0\xa0\xa0 table.insert(boxList,insertedObjects[ 1 ]) \n \xa0\xa0\xa0\xa0 table.insert(boxDummyList,insertedObjects[ 2 ])  \n \xa0\xa0\xa0\xa0 - -   Decide  if   object   is   good  or   bad \n \xa0\xa0\xa0\xa0 local decision  =   math.random()  \n \xa0\xa0\xa0\xa0 if   decision < =   goodPercentage then \n \xa0\xa0\xa0\xa0 - -   Object   is   good, assign goodColor \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setShapeColor(insertedObjects[ 1 ],nil,sim.colorcomponent_ambient_diffuse,goodColor) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.insert(boolList,true) \n \xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0 - -   Object   is   bad, assign random color \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setShapeColor(insertedObjects[ 1 ],nil,sim.colorcomponent_ambient_diffuse,{rand1,rand2,rand3}) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.insert(boolList,false) \n \xa0\xa0\xa0\xa0 end \n end \n \n \n \n \n \n \n \n 手臂末端加入 components-gripper-suction pad 吸盤 \xa0 \n 逆向運動學函式. \n Python remote API 逆向運動學函式 \n \n 取分項目3: 末端接上 force sensor 後接上標準 suction pad\xa0 \n 檔案 \n 程式碼(lua) \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n 127 \n 128 \n 129 \n 130 \n 131 \n 132 \n 133 \n 134 \n 135 \n 136 \n 137 \n 138 \n 139 \n 140 \n 141 \n 142 \n 143 \n 144 \n 145 \n 146 \n 147 \n 148 \n 149 \n 150 \n 151 \n 152 \n 153 \n 154 \n 155 \n 156 \n 157 \n 158 \n 159 \n 160 \n 161 \n 162 \n 163 \n 164 \n 165 \n 166 \n 167 \n 168 \n 169 \n \n \n \n function sysCall_init()  \n \xa0\xa0\xa0\xa0 axis1 = sim.getObjectHandle( \'MTB_axis1\' ) \n \xa0\xa0\xa0\xa0 axis2 = sim.getObjectHandle( \'MTB_axis2\' ) \n \xa0\xa0\xa0\xa0 axis3 = sim.getObjectHandle( \'MTB_axis3\' ) \n \xa0\xa0\xa0\xa0 axis4 = sim.getObjectHandle( \'MTB_axis4\' ) \n \xa0\xa0\xa0\xa0 mtb3 = sim.getObjectHandle( \'MTB_link3Respondable\' ) \n \xa0\xa0\xa0\xa0 suctionPad = sim.getObjectHandle( \'suctionPad\' ) \n \xa0\xa0\xa0\xa0 BaseFrame = sim.getObjectHandle( "BaseFrame" ) \n \xa0\xa0\xa0\xa0 block  = sim.getObjectHandle( "block" ) \n \xa0\xa0\xa0\xa0 rotation1  =   0 \n \xa0\xa0\xa0\xa0 rotation2  =   0 \n \xa0\xa0\xa0\xa0 distance3  =   0 \n \xa0\xa0\xa0\xa0 deg  =   math.pi / 180 \n end \n function sysCall_actuation()  \n \xa0\xa0\xa0\xa0 - -   吸盤往下降時, 直接貼在方塊頂部的校正值, 單位 m \n \xa0\xa0\xa0\xa0 - -   向下較正值為  4.2   mm \n \xa0\xa0\xa0\xa0 calibration  =   0.0042 \n \xa0\xa0\xa0\xa0 message, auxiliaryData = sim.getSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 while   message ~ =   - 1   do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 key = auxiliaryData[ 1 ] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.addStatusbarMessage( \'使用者按下 key:\' ..key) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (message = = sim.message_keypress) then \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 97 ) then  - - r right turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key r pressed axis1 angle adds  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation1  =   rotation1  +   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   r \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 115 ) then  - - l left turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key l pressed axis1 angle substract  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation1  =   rotation1  -   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis1, rotation1) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   l \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 122 ) then  - - r right turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key r pressed axis1 angle adds  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation2  =   rotation2  +   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis2, rotation2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   r \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 120 ) then  - - l left turn  in   degree \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key l pressed axis1 angle substract  5   degrees \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 rotation2  =   rotation2  -   5 * deg \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis2, rotation2) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   l \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 112 ) then  - - p activate the suction pad \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key p pressed activate the suction mode \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad), \'active\' , \'true\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   p \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 113 ) then  - - q deactivate the suction pad \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key q pressed deactivate the suction mode \n sim.setScriptSimulationParameter(sim.getScriptAssociatedWithObject(suctionPad), \'active\' , \'false\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   q \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 100 ) then  - - d suction pad down \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key d pressed axis3 will down  0.01   m plus calibration \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance3  =   distance3  +   0.01   +   calibration \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   d \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (auxiliaryData[ 1 ] = = 117 ) then  - - u suction pad up \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   if   key u pressed axis3 will up  0.01   m minus calibration \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   吸盤往下升  1   公分加上校正值 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 distance3  =   distance3  -   0.01   -   calibration \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setJointPosition(axis3, distance3) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   if   u \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end\xa0  - -   if \n \xa0\xa0\xa0\xa0 message, auxiliaryData = sim.getSimulatorMessage() \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end  - -   while \n end  - -   function \n function sysCall_sensing()  \n - - [[ \n \xa0\xa0\xa0\xa0 - -   Read Proximity sensor ( 0 =   nothing detected,  1   =   object   detected) \n \xa0\xa0\xa0\xa0 local res  =   sim.readProximitySensor(proximity) \n \xa0\xa0\xa0\xa0 - -   Check  if   possible to insert an new box \n \xa0\xa0\xa0\xa0 if   (sim.getSimulationTime() - T_last_inserted > T_insert)  and   not   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 insertBox() \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   If proximity sensor detects an  object , stop the belt, stop inserting objects \n \xa0\xa0\xa0\xa0 if   res  = =   1   and   not   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   boolList[ 1 ] then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setScriptSimulationParameter(sim.handle_self, "conveyorBeltVelocity" , 0 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 deltaTime  =   sim.getSimulationTime() - T_last_inserted \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 hasStopped  =   true \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local box  =   table.remove(boxList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 local boxDummy  =   table.remove(boxDummyList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.remove(boolList, 1 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.removeObject(box) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.removeObject(boxDummy) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   If proximity sensor detects nothing  and   belt has stopped, start belt,  continue   inserting \n \xa0\xa0\xa0\xa0 if   res  = =   0   and   hasStopped then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setScriptSimulationParameter(sim.handle_self, "conveyorBeltVelocity" ,beltSpeed) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 hasStopped  =   false \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 T_last_inserted  =   sim.getSimulationTime() - deltaTime \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 \xa0 \n ]] - - \n end \n function sysCall_cleanup()  \n end  \n - -   Convert a lua table into a lua syntactically correct string \n function table_to_string(tbl) \n \xa0\xa0\xa0\xa0 local result  =   "{" \n \xa0\xa0\xa0\xa0 for   k, v  in   pairs(tbl) do \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   Check the key  type   (ignore  any   numerical keys  -   assume its an array) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   type (k)  = =   "string"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "[\\"" ..k.. "\\"]" .. "=" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 - -   Check the value  type \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   type (v)  = =   "table"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result..table_to_string(v) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 elseif  type (v)  = =   "boolean"   then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result..tostring(v) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 v  =   round (v,  4 ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "\\"" ..v.. "\\"" \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result.. "," \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 - -   Remove leading commas  from   the result \n \xa0\xa0\xa0\xa0 if   result ~ =   "" then \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 result  =   result:sub( 1 , result: len () - 1 ) \n \xa0\xa0\xa0\xa0 end \n \xa0\xa0\xa0\xa0 return   result.. "}" \n end \n function  round (x, n) \n \xa0\xa0\xa0\xa0 n  =   math. pow ( 10 , n  or   0 ) \n \xa0\xa0\xa0\xa0 x  =   x  *   n \n \xa0\xa0\xa0\xa0 if   x > =   0   then x  =   math.floor(x  +   0.5 )  else   x  =   math.ceil(x  -   0.5 ) end \n \xa0\xa0\xa0\xa0 return   x  /   n \n end \n \xa0 \n \xa0 \n function insertBox() \n \xa0\xa0\xa0\xa0 - -   Generate random numbers \n \xa0\xa0\xa0\xa0 local rand1  =   math.random() \n \xa0\xa0\xa0\xa0 local rand2  =   math.random() \n \xa0\xa0\xa0\xa0 local rand3  =   math.random() \n \xa0\xa0\xa0\xa0 - -   Generate random disturbances on position  and   orientation \n \xa0\xa0\xa0\xa0 local dx  =   ( 2 * rand1 - 1 ) * 0.1 \n \xa0\xa0\xa0\xa0 local dy  =   ( 2 * rand2 - 1 ) * 0.1 \n \xa0\xa0\xa0\xa0 local dphi  =   ( 2 * rand3 - 1 ) * 0.5 \n \xa0\xa0\xa0\xa0 local disturbedCoordinates  =   { 0 , 0 , 0 } \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 1 ]  =   insertCoordinate[ 1 ] + dx \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 2 ]  =   insertCoordinate[ 2 ] + dy \n \xa0\xa0\xa0\xa0 disturbedCoordinates[ 3 ]  =   insertCoordinate[ 3 ] \n \xa0\xa0\xa0\xa0 - -   Copy  and   paste box  and   boxDummy \n \xa0\xa0\xa0\xa0 local insertedObjects  =   sim.copyPasteObjects({box,boxDummy}, 0 ) \n \xa0\xa0\xa0\xa0 - -   Update last inserted box time \n \xa0\xa0\xa0\xa0 T_last_inserted  =   sim.getSimulationTime() \n \xa0\xa0\xa0\xa0 - -   Move  and   rotate \n \xa0\xa0\xa0\xa0 sim.setObjectPosition(insertedObjects[ 1 ], - 1 ,disturbedCoordinates) \n \xa0\xa0\xa0\xa0 sim.setObjectOrientation(insertedObjects[ 1 ], - 1 ,{ 0 , 0 ,dphi}) \n \xa0\xa0\xa0\xa0 - -   Store handles to boxes  and   dummies \n \xa0\xa0\xa0\xa0 table.insert(boxList,insertedObjects[ 1 ]) \n \xa0\xa0\xa0\xa0 table.insert(boxDummyList,insertedObjects[ 2 ])  \n \xa0\xa0\xa0\xa0 - -   Decide  if   object   is   good  or   bad \n \xa0\xa0\xa0\xa0 local decision  =   math.random()  \n \xa0\xa0\xa0\xa0 if   decision < =   goodPercentage then \n \xa0\xa0\xa0\xa0 - -   Object   is   good, assign goodColor \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setShapeColor(insertedObjects[ 1 ],nil,sim.colorcomponent_ambient_diffuse,goodColor) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.insert(boolList,true) \n \xa0\xa0\xa0\xa0 else \n \xa0\xa0\xa0\xa0 - -   Object   is   bad, assign random color \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 sim.setShapeColor(insertedObjects[ 1 ],nil,sim.colorcomponent_ambient_diffuse,{rand1,rand2,rand3}) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 table.insert(boolList,false) \n \xa0\xa0\xa0\xa0 end \n end \n \n \n \n \n \n', 'tags': '', 'url': 'W16.html'}, {'title': 'W17', 'text': '期末報告影片 \n \n', 'tags': '', 'url': 'W17.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.', 'tags': '', 'url': 'Develop.html'}]};